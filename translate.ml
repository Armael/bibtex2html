(*
 * bibtex2html - A BibTeX to HTML translator
 * Copyright (C) 1997-2000 Jean-Christophe Filliâtre and Claude Marché
 * 
 * This software is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public
 * License version 2, as published by the Free Software Foundation.
 * 
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * 
 * See the GNU General Public License version 2 for more details
 * (enclosed in the file GPL).
 *)

(* $Id: translate.ml,v 1.42 2000-06-09 17:33:32 filliatr Exp $ *)

(* options *)

let nodoc = ref false
let nokeys = ref false
let file_suffix = ref ".html"
let link_suffix = ref ".html"
let raw_url = ref false
let title = ref ""
let title_spec = ref false
let print_abstract = ref true
let print_footer = ref true
let multiple = ref false
let both = ref false
let user_footer = ref ""
let bib_entries = ref true
let input_file = ref ""
let output_file = ref ""
let bibentries_file = ref ""

let (fields : string list ref) = ref []
let add_field s = fields := (String.uppercase s) :: !fields

let debug = ref false

(* first pass to get the crossrefs *)

let (cite_tab : (string,string) Hashtbl.t) = Hashtbl.create 17

let cpt = ref 0

let first_pass bl =
  let rec pass = function
      [] -> ()
    | (None,_,(_,k,_))::rem ->
	incr cpt;
	Hashtbl.add cite_tab k (string_of_int !cpt);
	pass rem
    | (Some c,_,(_,k,_))::rem ->
	Hashtbl.add cite_tab k c;
	pass rem
  in
    cpt := 0;
    Hashtbl.clear cite_tab;
    List.iter (fun (_,items) -> pass items) bl


(* latex2html : to print LaTeX strings in HTML format *)

open Latexmacros

let in_summary = ref false

let cite k =
  try
    let url =
      if !in_summary then 
	Printf.sprintf "#%s" k
      else
	Printf.sprintf "%s%s#%s" !output_file !link_suffix k in
    let c = Hashtbl.find cite_tab k in
      print_s (Printf.sprintf "<A HREF=\"%s\">[%s]</A>" url c)
  with
      Not_found -> print_s "[?]"

let _ = def "\\cite" [ Raw_arg cite ]

let latex2html ch s =
  Latexmacros.out_channel := ch;
  Latexscan.brace_nesting := 0;
  Latexscan.main (Lexing.from_string s)

let safe_title e =
  try Expand.get_title e with Not_found -> "No title"


(* header and footer of HTML files *)

let own_address = "http://www.lri.fr/~filliatr/bibtex2html/"

let header ch =
  Printf.fprintf ch "
<!-- This document was automatically generated with bibtex2html %s
     (see http://www.lri.fr/~filliatr/bibtex2html/),
     with the following command:
     " Version.version;
  Array.iter (Printf.fprintf ch "%s ") Sys.argv;
  output_string ch " -->\n\n"

let footer ch =
  Html.open_balise ch "HR";
  Html.open_balise ch "EM";
  output_string ch "This file has been generated by\n";
  Html.open_href ch own_address;
  output_string ch "bibtex2html";
  Html.close_href ch;
  output_string ch " "; output_string ch Version.version;
  Html.close_balise ch "EM"; output_string ch "\n";
  output_string ch !user_footer

(* links (other than BibTeX entry, when available) *)

let compression_suffixes = [ ".gz"; ".Z"; ".zip" ]

let decompressed f = 
  let rec test_comp = function
      [] -> (false,f)
    | suff :: r -> 
	if Filename.check_suffix f suff then
	  (true,Filename.chop_suffix f suff)
	else
	  test_comp r
  in
  test_comp compression_suffixes

let file_types = [ ".dvi","DVI"; ".ps","PS"; ".pdf","PDF"; ".rtf","RTF" ]

let file_type f =
  let (comp,f) = decompressed f in
  let rec test_type = function
      [] -> "Available here"
    | (suff,name)::rem ->
	if Filename.check_suffix f suff then
	  (if comp then "Compressed " else "") ^ name
	else
	  test_type rem
  in
  test_type file_types

let rec is_url s =
  (String.length s > 3 & String.lowercase (String.sub s 0 4) = "http")
  or  (String.length s > 2 & String.lowercase (String.sub s 0 3) = "ftp")
  or  (String.length s > 3 & String.lowercase (String.sub s 0 4) = "www:")

let get_url s =
  if (String.length s > 3 & String.lowercase (String.sub s 0 4) = "www:") then
    String.sub s 4 (String.length s - 4)
  else
    s

let make_links ch ((t,k,_) as e) startb =
  (* URL's *)
  let first = ref startb in
  List.iter (fun u -> 
	       try
		 let u = Expand.get_uppercase_field e u in
		 let s = file_type u in
		 if !first then first := false else output_string ch ",\n";
		 let url = get_url u in
		 Html.open_href ch url;
		 output_string ch (if !raw_url then url else s);
		 Html.close_href ch
	       with Not_found -> ())
    (!fields @ 
     [ "FTP"; "HTTP"; "URL"; "DVI"; "PS"; "PDF";
       "DOCUMENTURL"; "URLPS"; "URLDVI"; "URLPDF" ])

let make_abstract ch ((t,k,_) as e) =
  try
    let a = Expand.get_uppercase_field e "ABSTRACT" in
      if is_url a then begin
	(* 1. it is an URL *)
	output_string ch ", ";
	Html.open_href ch (get_url a);
	output_string ch "Abstract";
	Html.close_href ch;
      end else if !print_abstract then begin
	(* 2. we have to print it right here *)
	Html.paragraph ch; output_string ch "\n";
	if not !multiple then Html.open_balise ch "font size=-1";
	Html.open_balise ch "blockquote";
	output_string ch "\n";
	latex2html ch a;
	Html.close_balise ch "blockquote";
	if not !multiple then Html.close_balise ch "font";
	output_string ch "\n";
	Html.paragraph ch; output_string ch "\n"
      end else if !both then begin
	(* 3. we have to insert a link to the file f-abstracts *)
	output_string ch ", ";
	let url = 
	  Printf.sprintf "%s-abstracts%s#%s" !output_file !link_suffix k in
	Html.open_href ch url;
	output_string ch "Abstract";
	Html.close_href ch;
      end
  with Not_found -> ()

(* Printing of one entry *)  

let bibtex_entry ch k =
  Html.open_href ch 
    (Printf.sprintf "%s%s#%s" !bibentries_file !link_suffix k);
  output_string ch "BibTeX entry";
  Html.close_href ch

let separate_file (b,((_,k,f) as e)) =
  in_summary := false;
  let file = k ^ !file_suffix in
  let ch = open_out file in
  let title = Printf.sprintf "%s : %s" !output_file k in
  if not !nodoc then
    Html.open_document ch (fun () -> output_string ch title);
  header ch;
  Html.open_balise ch "h2";
  latex2html ch b;
  Html.close_balise ch "h2";
  Html.paragraph ch;
  make_abstract ch e;
  Html.paragraph ch;
  bibtex_entry ch k;
  Html.paragraph ch;
  make_links ch e true;
  Html.paragraph ch;
  Html.open_href ch (!output_file ^ !link_suffix);
  output_string ch "Back";
  Html.close_href ch;
  if !print_footer then footer ch;
  if not !nodoc then Html.close_document ch;
  close_out ch;
  in_summary := true

let one_entry_summary ch (_,b,((_,k,f) as e)) =
  if !debug then begin
    Printf.eprintf "[%s]" k; flush stderr
  end;
  output_string ch "\n\n";
  Html.open_balise ch "tr valign=top";

  output_string ch "\n";
  Html.open_balise ch "td align=right"; output_string ch "\n";
  Html.open_anchor ch k; Html.close_anchor ch;
  if (not !nokeys) or !multiple then begin
    output_string ch "[";
    if !multiple then Html.open_href ch (k ^ !link_suffix);
    latex2html ch (Hashtbl.find cite_tab k);
    if !multiple then Html.close_href ch;
    output_string ch "]"
  end;
  (* Html.close_anchor ch; *)
  output_string ch "\n"; 
  Html.close_balise ch "td"; output_string ch "\n";

  Html.open_balise ch "td"; output_string ch "\n";
  latex2html ch b;
  Html.open_balise ch "BR";
  output_string ch "\n";

  if !multiple then
    separate_file (b,e)
  else begin
    if !bib_entries then bibtex_entry ch k;
    make_links ch e (not !bib_entries);
    make_abstract ch e
  end;
  output_string ch "\n"; 
  Html.close_balise ch "td"; output_string ch "\n"

(* summary file f.html *)

let summary bl =
  let (ch,filename) = 
    if !output_file = "" then 
      (stdout, "standard output")
    else
      let filename = !output_file ^ !file_suffix in
      (open_out filename, filename)
  in
  Printf.eprintf "Making HTML document (%s)..." filename; flush stderr;
  if not !nodoc then
    Html.open_document ch (fun () -> output_string ch !title);
  header ch;
  if !title_spec then Html.h1_title ch !title;
  output_string ch "\n";
  
  in_summary := true;
  List.iter
    (fun (name,el) ->
       begin match name with
	 | None -> ()
	 | Some s ->
	     Html.open_balise ch "H2";
	     latex2html ch s;
	     Html.close_balise ch "H2";
	     output_string ch "\n"
       end;
       Html.open_balise ch "table";
       List.iter (one_entry_summary ch) el;
       Html.close_balise ch "table")
    bl;
  in_summary := false;
  if !print_footer then footer ch;
  if not !nodoc then Html.close_document ch;
  close_out ch;
  Printf.eprintf "ok\n"; flush stderr


(* HTML file with BibTeX entries f-bib.html *)

let print_list print sep l = 
  let rec print_rec = function
    | [] -> ()
    | [x] -> print x
    | x::r -> print x; sep(); print_rec r
  in
  print_rec l


let bib_file bl keys =
  let fn = !bibentries_file ^ !file_suffix in
  Printf.eprintf "Making HTML list of BibTeX entries (%s)..." fn;
  flush stderr;
  let ch = open_out fn in

  if not !nodoc then
    Html.open_document ch (fun _ -> output_string ch !input_file);

  Html.open_balise ch "H1";
  output_string ch !input_file;
  Html.close_balise ch "H1";

  Html.open_balise ch "PRE";
  Biboutput.output_bib true ch bl keys;
  Html.close_balise ch "PRE";
  
  if !print_footer then footer ch;
  if not !nodoc then Html.close_document ch;
  flush ch;
  close_out ch;
  Printf.eprintf "ok\n"; flush stderr


(* main function *)

let format_list entries sorted_bl keys =
  first_pass sorted_bl;
  bibentries_file := !output_file ^ "-bib";
  if !both then begin
    (* short version *)
    print_abstract := false;
    summary sorted_bl;
    (* long version with abstracts *)
    print_abstract := true;
    let old_output = !output_file in
    output_file := !output_file ^ "-abstracts";
    summary sorted_bl;
    output_file := old_output
  end else
    summary sorted_bl;
  (* BibTeX entries file *)
  if !bib_entries then bib_file entries keys

