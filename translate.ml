(*
 * bibtex2html - A BibTeX to HTML translator
 * Copyright (C) 1997-2000 Jean-Christophe Filliâtre and Claude Marché
 * 
 * This software is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public
 * License version 2, as published by the Free Software Foundation.
 * 
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * 
 * See the GNU General Public License version 2 for more details
 * (enclosed in the file GPL).
 *)

(*i $Id: translate.ml,v 1.52 2001-10-17 12:51:42 filliatr Exp $ i*)

(*s Production of the HTML documents from the BibTeX bibliographies. *)

open Printf

(*s Options. *)

let nodoc = ref false
let nokeys = ref false
let file_suffix = ref ".html"
let link_suffix = ref ".html"
let raw_url = ref false
let title = ref ""
let title_spec = ref false
let print_abstract = ref true
let print_footer = ref true
let multiple = ref false
let both = ref false
let user_footer = ref ""
let bib_entries = ref true
let input_file = ref ""
let output_file = ref ""
let bibentries_file = ref ""
let title_url = ref false
let use_label_name = ref false
let table = ref true

(* internal name, plus optional external name *)
type field_info = string * (string option)

let default_fields =
  List.map (fun x -> x, None) 
    ["FTP"; "HTTP"; "URL"; "DVI"; "PS"; "PDF";
     "DOCUMENTURL"; "URLPS"; "URLDVI"; "URLPDF"]

let (fields : field_info list ref) = ref default_fields

let add_field s = 
  let u = String.uppercase s in 
  fields := (u, None) :: (List.remove_assoc u !fields)

let add_named_field s name = 
  let u = String.uppercase s in 
  fields := (u, Some name) :: (List.remove_assoc u !fields)

(* first pass to get the crossrefs *)

let (cite_tab : (string,string) Hashtbl.t) = Hashtbl.create 17

let cpt = ref 0

let first_pass bl =
  let rec pass = function
    | [] -> ()
    | (None,_,(_,k,_)) :: rem ->
	incr cpt;
	Hashtbl.add cite_tab k (string_of_int !cpt);
	pass rem
    | (Some c,_,(_,k,_)) :: rem ->
	Hashtbl.add cite_tab k c;
	pass rem
  in
  cpt := 0;
  Hashtbl.clear cite_tab;
  List.iter (fun (_,items) -> pass items) bl


(* latex2html : to print LaTeX strings in HTML format *)

open Latexmacros

let in_summary = ref false

let cite k =
  try
    let url =
      if !in_summary then 
	sprintf "#%s" k
      else
	sprintf "%s%s#%s" !output_file !link_suffix k in
    let c = Hashtbl.find cite_tab k in
      print_s (sprintf "<A HREF=\"%s\">[%s]</A>" url c)
  with
      Not_found -> print_s "[?]"

let _ = def "\\cite" [ Raw_arg cite ]

let latex2html ch s =
  Latexmacros.out_channel := ch;
  Latexscan.brace_nesting := 0;
  Latexscan.main (Lexing.from_string s)

let safe_title e =
  try Expand.get_title e with Not_found -> "No title"


(* header and footer of HTML files *)

let own_address = "http://www.lri.fr/~filliatr/bibtex2html/"

let header ch =
  let print_arg s =
    if String.contains s ' ' then 
      fprintf ch "\"%s\" " s 
    else 
      fprintf ch "%s " s
  in
  fprintf ch "
<!-- This document was automatically generated with bibtex2html %s
     (see http://www.lri.fr/~filliatr/bibtex2html/),
     with the following command:
     " Version.version;
  Array.iter print_arg Sys.argv;
  output_string ch " -->\n\n"

let footer ch =
  Html.open_balise ch "HR";
  Html.open_balise ch "EM";
  output_string ch "This file has been generated by\n";
  Html.open_href ch own_address;
  output_string ch "bibtex2html";
  Html.close_href ch;
  output_string ch " "; output_string ch Version.version;
  Html.close_balise ch "EM"; output_string ch "\n";
  output_string ch !user_footer

(* links (other than BibTeX entry, when available) *)

let compression_suffixes = [ ".gz"; ".Z"; ".zip" ]

let file_suffixes =
  List.flatten 
    (List.map (fun s -> s :: List.map ((^) s) compression_suffixes)
       [ ".dvi"; ".DVI"; ".ps"; ".PS"; ".pdf"; ".PDF"; 
	 ".rtf"; ".RTF"; ".txt"; ".TXT"; ".html"; ".HTML" ])

let is_http s =
  String.length s > 3 & String.lowercase (String.sub s 0 4) = "http"

let is_ftp s =
  String.length s > 2 & String.lowercase (String.sub s 0 3) = "ftp"

let is_www s =
  String.length s > 3 & String.lowercase (String.sub s 0 4) = "www:"

let is_url s = is_http s || is_ftp s || is_www s

let file_type f =
  try
    List.find (Filename.check_suffix f) file_suffixes
  with Not_found ->
    if is_http f then "http" else if is_ftp f then "ftp" else "www"

let get_url s =
  if (String.length s > 3 & String.lowercase (String.sub s 0 4) = "www:") then
    String.sub s 4 (String.length s - 4)
  else
    s

let link_name (u, name) url s =
  match name with
  | Some name ->
      name
  | None ->
      if !raw_url then 
	url 
      else if !use_label_name then 
	String.capitalize (String.lowercase u)
      else
	s

let make_links ch ((t,k,_) as e) startb =
  (* URL's *)
  let first = ref startb in
  List.iter 
    (fun ((f, _) as info) -> 
       try
	 let u = Expand.get_uppercase_field e f in
	 let s = file_type u in
	 if !first then first := false else output_string ch " | \n";
	 let url = get_url u in
	 Html.open_href ch url;
	 output_string ch (link_name info url s);
	 Html.close_href ch
       with Not_found -> ())
    !fields

let make_abstract ch ((t,k,_) as e) =
  try
    let a = Expand.get_uppercase_field e "ABSTRACT" in
      if is_url a then begin
	(* 1. it is an URL *)
	output_string ch " | ";
	Html.open_href ch (get_url a);
	output_string ch "Abstract";
	Html.close_href ch;
	output_string ch " ]\n"
      end else if !print_abstract then begin
	output_string ch " ]\n";
	(* 2. we have to print it right here *)
	Html.paragraph ch; output_string ch "\n";
	Html.open_balise ch "blockquote";
	if not !multiple then Html.open_balise ch "font size=-1";
	output_string ch "\n";
	latex2html ch a;
	if not !multiple then Html.close_balise ch "font";
	Html.close_balise ch "blockquote";
	output_string ch "\n";
	Html.paragraph ch; output_string ch "\n"
      end else if !both then begin
	(* 3. we have to insert a link to the file f-abstracts *)
	output_string ch " | ";
	let url = sprintf "%s-abstracts%s#%s" !output_file !link_suffix k in
	Html.open_href ch url;
	output_string ch "Abstract";
	Html.close_href ch;
	output_string ch " ]\n"
      end
  with Not_found -> 
    output_string ch " ]\n"

(* Printing of one entry *)  

let bibtex_entry ch k =
  Html.open_href ch 
    (sprintf "%s%s#%s" (Filename.basename !bibentries_file) !link_suffix k);
  output_string ch "bib";
  Html.close_href ch

let separate_file (b,((_,k,f) as e)) =
  in_summary := false;
  let file = k ^ !file_suffix in
  let ch = open_out file in
  let title = sprintf "%s : %s" !output_file k in
  if not !nodoc then
    Html.open_document ch (fun () -> output_string ch title);
  header ch;
  Html.open_balise ch "h2";
  latex2html ch b;
  Html.close_balise ch "h2";
  Html.paragraph ch;
  make_abstract ch e;
  Html.paragraph ch;
  bibtex_entry ch k;
  Html.paragraph ch;
  make_links ch e true;
  Html.paragraph ch;
  Html.open_href ch (!output_file ^ !link_suffix);
  output_string ch "Back";
  Html.close_href ch;
  if !print_footer then footer ch;
  if not !nodoc then Html.close_document ch;
  close_out ch;
  in_summary := true

let open_table ch = 
  Html.open_balise ch (if !table then "table" else "dl")

let close_table ch =
  Html.close_balise ch (if !table then "table" else "dl")

let open_row ch =
  if !table then begin
    Html.open_balise ch "tr valign=top"; output_string ch "\n";
    Html.open_balise ch "td align=right"; output_string ch "\n"
  end else begin
    Html.open_balise ch "dt"; output_string ch "\n"
  end

let new_column ch =
  if !table then begin
    Html.close_balise ch "td"; output_string ch "\n";
    Html.open_balise ch "td"; output_string ch "\n"
  end else begin
    Html.close_balise ch "dt"; output_string ch "\n";
    Html.open_balise ch "dd"; output_string ch "\n"
  end

let close_row ch =
  if !table then begin
    Html.close_balise ch "td"; output_string ch "\n";
    Html.close_balise ch "tr"; output_string ch "\n"
  end else begin
    Html.paragraph ch; output_string ch "\n";
    Html.close_balise ch "dd"; output_string ch "\n"
  end

let one_entry_summary ch (_,b,((_,k,f) as e)) =
  if !Options.debug then begin
    eprintf "[%s]" k; flush stderr
  end;
  output_string ch "\n\n";
  open_row ch;
  Html.open_anchor ch k; Html.close_anchor ch;
  if (not !nokeys) or !multiple then begin
    output_string ch "[";
    if !multiple then Html.open_href ch (k ^ !link_suffix);
    latex2html ch (Hashtbl.find cite_tab k);
    if !multiple then Html.close_href ch;
    output_string ch "]"
  end;
  (*i Html.close_anchor ch; i*)
  output_string ch "\n"; 
  new_column ch;
  latex2html ch b;
  Html.open_balise ch "BR";
  output_string ch "\n";

  if !multiple then
    separate_file (b,e)
  else begin
    output_string ch "[ ";
    if !bib_entries then bibtex_entry ch k;
    make_links ch e (not !bib_entries);
    make_abstract ch e
  end;
  output_string ch "\n"; 
  close_row ch

(* summary file f.html *)

let summary bl =
  let (ch,filename) = 
    if !output_file = "" then 
      (stdout, "standard output")
    else
      let filename = !output_file ^ !file_suffix in
      (open_out filename, filename)
  in
  if not !Options.quiet then begin
    eprintf "Making HTML document (%s)..." filename; flush stderr
  end;
  if not !nodoc then
    Html.open_document ch (fun () -> output_string ch !title);
  header ch;
  if !title_spec then Html.h1_title ch !title;
  output_string ch "\n";
  
  in_summary := true;
  List.iter
    (fun (name,el) ->
       begin match name with
	 | None -> ()
	 | Some s ->
	     Html.open_balise ch "H2";
	     latex2html ch s;
	     Html.close_balise ch "H2";
	     output_string ch "\n"
       end;
       open_table ch;
       List.iter (one_entry_summary ch) el;
       close_table ch)
    bl;
  in_summary := false;
  if !print_footer then footer ch;
  if not !nodoc then Html.close_document ch;
  close_out ch;
  if not !Options.quiet then begin eprintf "ok\n"; flush stderr end


(* HTML file with BibTeX entries f-bib.html *)

let print_list print sep l = 
  let rec print_rec = function
    | [] -> ()
    | [x] -> print x
    | x::r -> print x; sep(); print_rec r
  in
  print_rec l


let bib_file bl keys =
  let fn = !bibentries_file ^ !file_suffix in
  if not !Options.quiet then begin
    eprintf "Making HTML list of BibTeX entries (%s)..." fn;
    flush stderr
  end;
  let ch = open_out fn in

  if not !nodoc then
    Html.open_document ch (fun _ -> output_string ch !input_file);

  Html.open_balise ch "H1";
  output_string ch !input_file;
  Html.close_balise ch "H1";

  Html.open_balise ch "PRE";
  Biboutput.output_bib true ch bl keys;
  Html.close_balise ch "PRE";
  
  if !print_footer then footer ch;
  if not !nodoc then Html.close_document ch;
  flush ch;
  close_out ch;
  if not !Options.quiet then begin eprintf "ok\n"; flush stderr end


(* main function *)

let format_list entries sorted_bl keys =
  first_pass sorted_bl;
  bibentries_file := !output_file ^ "-bib";
  if !both then begin
    (* short version *)
    print_abstract := false;
    summary sorted_bl;
    (* long version with abstracts *)
    print_abstract := true;
    let old_output = !output_file in
    output_file := !output_file ^ "-abstracts";
    summary sorted_bl;
    output_file := old_output
  end else
    summary sorted_bl;
  (* BibTeX entries file *)
  if !bib_entries then bib_file entries keys

