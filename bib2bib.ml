

open Printf;;
open Bibtex;;


(*
let print_entry (entry_type,key,fields) = 
  printf "@%s{%s,\n" entry_type key;
  List.iter 
    (fun (field,value) ->
       printf "  %s = {%s}\n" field value)
    fields;
  printf "}\n\n"
;;

let string_of_atom = function
    Id s -> s
  | String s -> "{"^s^"}"
;;

let print_atom_list = function 
    [] -> ()
  | a::l ->
      printf " %s" (string_of_atom a);
      List.iter
	(fun a -> printf " # %s" (string_of_atom a))
	l
;;


let get_key = function
    Entry(_,key,_) -> key
  | Abbrev(key,_) -> key
  | _ -> ""
;;

let print_command = function 
    Comment -> 
      printf "(comment)\n\n"
  | Preamble s ->
      printf "(preamble = %s)\n" s
  | Abbrev(s,l) ->
      printf "@string{%s =" s;
      print_atom_list l;
      printf "\n\n"
  | Entry (entry_type,key,fields) ->
      printf "@%s{%s" entry_type key;
      List.iter
	(fun (field,l) ->
	   printf ",\n  %s =" field;
           print_atom_list l)
	fields;
      printf "\n}\n\n"

;;

*)
  

(* [(read_entries_from_file f)] returns the BibTeX entries of the
   BibTeX file [f]. Raises [Syntax_error n] if a syntax error is met
   on line [n] *)

exception Syntax_error of int;;

let read_entries_from_file f =

  Bibtex_lexer.reset();
  let chan = open_in f in
  try
    let el =
      Bibtex_parser.command_list Bibtex_lexer.token (Lexing.from_channel chan)
    in
      close_in chan;
      el

  with
      Parsing.Parse_error | Failure "unterminated string" ->
	close_in chan;
	raise (Syntax_error !Bibtex_lexer.line)
	  

(*
let test_criteria fields =
  try
    let date = List.assoc "YEAR" fields
    in date = [Id("1996")]
  with
      Not_found -> false
;;
*)

let test_criteria fields =
  try
    let [String(author)] = List.assoc "AUTHOR" fields
    in 
      try

	let _ = Str.search_forward 
		  (Str.regexp_case_fold "claude march")
		  author
		  0
	in true
      with
	  Not_found -> false
  with
      Not_found -> false
;;



let do_file file =
  try
    printf "Reading %s..." file; 
    flush stdout;
    let entries = read_entries_from_file file
    in
      printf "ok (%d entries).\n" (List.length entries); 
      flush stdout;    
      (*
	List.iter print_command entries;
      *)
      entries

  with
      Syntax_error n ->
	printf "Parse error line %d.\n" !Bibtex_lexer.line;
      flush stdout;
      exit 1 
;;



(* command-line arguments *)

let input_file_names = ref ([] : string list);;

let bib_output_file_name = ref "";;

let cite_output_file_name = ref "";;

let get_input_file_name f =
  input_file_names := f :: !input_file_names;;

let args_spec =
  [
    ("-ob", 
     Arg.String(fun f -> bib_output_file_name := f),"bib output file name");
    ("-oc",
     Arg.String(fun f -> cite_output_file_name := f),"citations output file name");
  ]


let output_cite_file keys = 
  try
    let ch =
      if !cite_output_file_name = "" then stdout
      else open_out !cite_output_file_name
    in
      KeySet.iter (fun k -> output_string ch (k ^ "\n")) keys;
      if !cite_output_file_name <> "" then close_out ch
  with
      Sys_error msg ->
	prerr_endline ("Cannot write output citations file (" ^ msg ^ ")");
	exit 1
;;


let output_bib_file biblio keys =
if !bib_output_file_name = "" then 
  printf "No bib output (no file name specified)\n"
else
  try    
    let ch = open_out !bib_output_file_name in 
    let cmd = List.fold_right (fun s t -> " "^s^t) (Array.to_list Sys.argv) "" in
      Biboutput.output_bib false ch 
	((Comment "This file has been generated by bib2bib") ::
	 (Comment ("Command line:" ^ cmd)) ::
	 biblio )
	keys;
      close_out ch
  with
      Sys_error msg ->
	prerr_endline ("Cannot write output bib file (" ^ msg ^ ")");
	exit 1
;;


let main () =
  Arg.parse args_spec get_input_file_name "Usage: bib2bib [options] <input file names>\nOptions are:";
  let all_entries =
    List.fold_left
      (fun l file -> l@(do_file file))
      []
      (List.rev !input_file_names)
  in    
  let matching_keys =
    Bibfilter.filter all_entries test_criteria 
  in
  let needed_keys =
    Bibfilter.saturate all_entries matching_keys
  in
    (*
      let needed_entries =
      List.filter
      (fun entry -> StringSet.mem (get_key entry) needed_keys)
      all_entries
      in		 
      List.iter print_command needed_entries
    *)
    output_cite_file matching_keys;
    output_bib_file all_entries (Some needed_keys)
;;




Printexc.catch main ();;

  
  
